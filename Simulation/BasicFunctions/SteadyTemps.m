function [T,HTcond,HTconv,HTrad]= SteadyTemps(block,mdot_Cp,T_in)
%Solve problem of form xdot = Ax-b for xdot =0.
%final solution is x = A\b;
%states represent  heat transfer into each node/layer, the temperatures of each node/layers, and inlet Flow2 and Flow1 temperatures, Qerror term associated with the small error in air flow rate so that the deltaT and Tavg constraints can both be satisfied
%like the heat exchanger this averages the inlet and exit temperature for the gas streams, and assumes the solid temperature states correspond to the average for the node
F=96485.339; % %Faraday's constant in Coulomb/mole
a = .5; %weighting of previous node temperature on convection HT calculation
nodes = block.nodes;
s = 2; %at minimum a flow and a solid mass (reformer)
inT = 1;
if length(T_in)>1
    s = 3; % 2 flows & a solid mass
    inT = 2;
end
if isfield(block,'FCtype') %fuel cell or electrolyzer
    [h,h_s] = enthalpy(block.T.Elec,{'H2','H2O','O2','CO','CO2','CH4'});
    h_rxn1 = h.CO+3*h.H2-h.CH4-h.H2O;
    h_rxn2 = h.CO2+h.H2-h.CO-h.H2O;
    Qreaction = block.Current.H2/(2000*F).*(h.H2+.5*h.O2-h.H2O) + block.Current.CO/(2000*F).*(h.CO+.5*h.O2-h.CO2);
    nPower = abs(block.Voltage)*(block.Current.H2+block.Current.CO)/1000;
    Q.gen = Qreaction - nPower;%kW of heat generated by electrochemistry (per node & per cell)
    if isfield(block,'R_CH4')
        Q.direct = h_rxn1.*block.R_CH4+h_rxn2.*block.R_WGS; %kW of cooling per cell;
    else
        Q.direct = zeros(block.nodes,1);
    end
    switch block.Reformer
        case 'internal'
            Q.indirect = h_rxn1.*block.R_CH4ref+h_rxn2.*block.R_WGSref; %kW of cooling per cell
            s=6; %3 flows and 3 solids
            Cells2Reformer=1; % set equal to 1 to model the cell next to the reformer
            C5 = (block.k_plate(2)*block.A_plate_elecCond(2)/block.L_plate_heatCond(2))/1000; %2nd half of split bi-polar plate to electrolyte
            C8 = (block.h_flow(3)*block.A_Node)/Cells2Reformer/1000;%reformer flow to 1st and 2nd half of bi-polar plate
        case {'adiabatic';'direct';'external';'none'}%  no direct heat transfer
            s=4; %2 flows and bi-polar plate and electrolyte
    end
    %ion transport across membrane (sensible enthalpy
    switch block.FCtype
        case {'SOFC';}%ion crosses from flow 1 to flow 2 in fuel cell mode and from flow 2 to flow 1 in electrolyzer mode. Current is negative in electrolyzer mode
            Q.ion = (block.Current.H2 + block.Current.CO)/(4*F*1000).*h_s.O2; %O2 ion crossing over (kW)
        case {'MCFC';}%ion crosses from flow 1 to flow 2 in fuel cell mode and from flow 2 to flow 1 in electrolyzer mode. Current is negative in electrolyzer mode
            Q.ion = (block.Current.H2 + block.Current.CO)/(4*F*1000).*h_s.O2 + abs(block.Current.H2 + block.Current.CO)/(2*F*1000).*h_s.CO2;% O2 & CO2 ion crossing over
    end
    c = length(block.Flow1Dir(1,:)); %extra constraint for average electrolyte temperature and column inlet to outlet
else%heat exchanger
    Q = [];
    c = 0;
end
states = 2*s*nodes+inT;

%% heat input/mass transfer terms
b = zeros(states+c,1);
if ~isempty(Q)
    % Solving Ax = b where: (1) heat transfer into node + heat gen + heat with mass transport + sum of {h*A*(T2-T1) + k*A*(T2-T1)/L + sig*ep*A*(T1^4-T2^4)} = 0
    % and (2) heat transfer into node - m*Cp*(T2-T1) = 0;
    for k = 1:1:nodes
        b(k+(s+1)*nodes) = Q.ion(k); %ion leaves this node (positive term when moved to right hand side of equality)
        b(k+(s+2)*nodes) = (-Q.gen(k)+ Q.direct(k));%heat generation occurs at electrolyte
        b(k+(s+3)*nodes) = -Q.ion(k);%ion enters this flow fuel/steam (negative term when moved to right hand side of equality)
        if s ==6
            b(k+(s+5)*nodes) = Q.indirect(k);
        end
    end
end
if isfield(block,'Qref')
    for k = 1:1:nodes
        b(k+s*nodes) = block.Qref(k);
    end
end
%% Convection transfer between flows and solids
A = zeros(states+c,states);
if s <=3
    %% This part is for heat exchanger (cold fluid, solid, hot fluid) or reformer (fluid, solid)
    hA = block.Convection;
    for k = 1:1:nodes
        %% averaging inlet and outlet temp for gaseous nodes
        %QT1 : heat transfer into primary flow
        A(k,k) = -1;
        A(k,k+(s+1)*nodes) = hA;
        A(k,k+s*nodes) = -(1-a)*hA;
        [i,j] = find(block.Flow1Dir==k);
        if j==1 %first column averaged with inlet temperature
            A(k,2*s*nodes+1) = -a*hA;
        else % other columns averaged with previous one
            k2 = block.Flow1Dir(i,j-1);
            A(k,k2+s*nodes) = -a*hA;
        end

        %QT2 : heat transfer into solid
        A(k+nodes,k+nodes) = -1;
        if s==2
            A(k+nodes,k+(s+1)*nodes) = -1*hA;
            A(k+nodes,k+s*nodes) = (1-a)*hA;
            if j==1 %first column averaged with inlet temperature
                A(k+nodes,2*s*nodes+1) = a*hA;
            else % other columns averaged with previous one
                A(k+nodes,k2+s*nodes) = a*hA;
            end
        elseif s==3
            A(k+nodes,k+(s+1)*nodes) = -2*hA;
            A(k+nodes,k+s*nodes) = (1-a)*hA;
            A(k+nodes,k+(s+2)*nodes) = (1-a)*hA;
            if j==1 %first column averaged with inlet temperature
                A(k+nodes,2*s*nodes+1) = a*hA;
            else % other columns averaged with previous one
                A(k+nodes,k2+s*nodes) = a*hA;
            end
            [i,j] = find(block.Flow2Dir==k);
            if j==1 %first column averaged with inlet temperature
                A(k+nodes,2*s*nodes+2) = a*hA;
            else
                k2 = block.Flow2Dir(i,j-1);
                A(k+nodes,k2+(s+2)*nodes) = a*hA;
            end

            %QT3 : heat transfer into hot flow
            A(k+2*nodes,k+2*nodes) = -1;
            A(k+2*nodes,k+(s+1)*nodes) = hA;
            A(k+2*nodes,k+(s+2)*nodes) = -(1-a)*hA;
            if j==1 %first column averaged with inlet temperature
                A(k+2*nodes,2*s*nodes+2) = -a*hA;
            else % other columns averaged with previous one
                A(k+2*nodes,k2+(s+2)*nodes) = -a*hA;
            end
        end

        %Tcold: Temperature of cold flow
        A(k+s*nodes,k) = 1;
        A(k+s*nodes,k+s*nodes) = -mdot_Cp(1);
        [i,j] = find(block.Flow1Dir==k);
        if j==1 %first column receives fresh air
            A(k+s*nodes,2*s*nodes+1) = mdot_Cp(1);
        else
            index = block.Flow1Dir(i,j-1);
            A(k+s*nodes,index +s*nodes) = mdot_Cp(1);
        end

        %Tsolid: Temperature of solid
        A(k+(s+1)*nodes,k+nodes) = 1;
        if s==3
            %Temperature of secondary flow
            A(k+(s+2)*nodes,k+2*nodes) = 1;
            A(k+(s+2)*nodes,k+(s+2)*nodes) = -mdot_Cp(2); 
            [i,j] = find(block.Flow2Dir==k);
            if j==1 %first column receives fresh flow
                A(k+(s+2)*nodes,2*s*nodes+2) = mdot_Cp(2); %fresh inlet
            else
                index = block.Flow2Dir(i,j-1);
                A(k+(s+2)*nodes,index + (s+2)*nodes) = mdot_Cp(2);
            end
        end
    end
    % remove gaseous temperature averaging from 1st node
    k1 = block.Flow1Dir(:,1); %first column
    for j =1:1:length(k1)
        k = k1(j);
        A(k,k+s*nodes) = A(k,k+s*nodes) -a*hA; %HT to cold flow from solid
        A(k,2*s*nodes+1) = A(k,2*s*nodes+1) +a*hA; %ignore cold flow inlet

        A(k+nodes,k+s*nodes) = A(k+nodes,k+s*nodes) +a*hA;%HT to solid from cold flow
        A(k+nodes,2*s*nodes+1) = A(k+nodes,2*s*nodes+1) -a*hA;%ignore cold flow inlet
    end
    if s==3
        k1 = block.Flow2Dir(:,1); %first column
        for j =1:1:length(k1)
            k = k1(j);
            A(k+2*nodes,k+(s+2)*nodes) = A(k+2*nodes,k+(s+2)*nodes) - a*hA; %HT to hot flow from solid
            A(k+2*nodes,2*s*nodes+2) = A(k+2*nodes,2*s*nodes+2) + a*hA; %ignore hot flow inlet

            A(k+nodes,k+(s+2)*nodes) = A(k+nodes,k+(s+2)*nodes) + a*hA;%HT to solid from hot flow
            A(k+nodes,2*s*nodes+2) = A(k+nodes,2*s*nodes+2) - a*hA;%ignore hot flow inlet
        end
    end
else
    %% This part is for the fuel cell / electrolyzer
    %all heat transfer coefficients converted to kW/K: thus Q = C*(T1-T2) is in kW
    C2 = (block.h_flow(1)*block.A_flow_plate(1))/1000;%bi-polar plate to air/oxidant stream
    C3 = (block.h_flow(1)*block.A_flow_elec(1))/1000;%air/oxidant stream to electrolyte
    C4 = (block.k_plate(1)*block.A_plate_elecCond(1)/block.L_plate_heatCond(1))/1000;%Bi-polar plate to electrolyt
    C6 = (block.h_flow(2)*block.A_flow_elec(2))/1000;% fuel/steam to electrolyte
    C7 = (block.h_flow(2)*block.A_flow_plate(2))/1000;% fuel/steam to 1st or 2nd bi-polar plate

    for k = 1:1:nodes
        %QT1 : heat transfer into oxidizer plate
        A(k,k) = A(k,k) - 1;
        if s==4
            A(k,k+s*nodes) =  A(k,k+s*nodes) - (C7+C2+C4);
            A(k,k+(s+3)*nodes) = A(k,k+(s+3)*nodes) + (1-a)*C7;
        elseif s==6
            A(k,k+s*nodes) = A(k,k+s*nodes) - (C8+C2+C4);
            A(k,k+(s+5)*nodes) = A(k,k+(s+5)*nodes) + (1-a)*C8;
        end
        A(k,k+(s+1)*nodes) = A(k,k+(s+1)*nodes) + (1-a)*C2; %averaged with inlet temp or previous node temp
        A(k,k+(s+2)*nodes) = A(k,k+(s+2)*nodes) + C4;

        %QT2 : heat transfer into Flow1
        A(k+nodes,k+nodes) = A(k+nodes,k+nodes) - 1;
        A(k+nodes,k+(s+1)*nodes) = A(k+nodes,k+(s+1)*nodes) - (1-a)*(C2+C3);
        A(k+nodes,k+s*nodes) = A(k+nodes,k+s*nodes) + C2;
        A(k+nodes,k+(s+2)*nodes) = A(k+nodes,k+(s+2)*nodes) + C3;

        [i,j] = find(block.Flow1Dir==k);
        if j==1 %first column averaged with inlet temperature
            A(k,2*s*nodes+2) = A(k,2*s*nodes+2) + a*C2;
            A(k+nodes,2*s*nodes+2) = A(k+nodes,2*s*nodes+2) - a*(C2+C3);
            A(k+2*nodes,2*s*nodes+2) = A(k+2*nodes,2*s*nodes+2) + a*C3;
        else % other columns averaged with previous one
            k2 = block.Flow1Dir(i,j-1);
            A(k,k2+(s+1)*nodes) = A(k,k2+(s+1)*nodes) + a*C2;
            A(k+nodes,k2+(s+1)*nodes) = A(k+nodes,k2+(s+1)*nodes) - a*(C2+C3);
            A(k+2*nodes,k2+(s+1)*nodes) = A(k+2*nodes,k2+(s+1)*nodes) + a*C3;
        end

        %QT3 : heat transfer into electrolyte
        A(k+2*nodes,k+2*nodes) = A(k+2*nodes,k+2*nodes) - 1;
        A(k+2*nodes,k+(s+2)*nodes) = A(k+2*nodes,k+(s+2)*nodes) - (C3+C4+C6);
        A(k+2*nodes,k+(s+1)*nodes) = A(k+2*nodes,k+(s+1)*nodes) + (1-a)*C3; %averaged with inlet temp or previous node temp
        A(k+2*nodes,k+s*nodes) = A(k+2*nodes,k+s*nodes) + C4;
        A(k+2*nodes,k+(s+3)*nodes) = A(k+2*nodes,k+(s+3)*nodes) + (1-a)*C6;

        %QT4 : heat transfer into Flow2
        A(k+3*nodes,k+3*nodes) = A(k+3*nodes,k+3*nodes) - 1;
        A(k+3*nodes,k+(s+3)*nodes) = A(k+3*nodes,k+(s+3)*nodes) - (1-a)*(C6+C7);
        A(k+3*nodes,k+(s+2)*nodes) = A(k+3*nodes,k+(s+2)*nodes) + C6;
        if s==6 
            A(k+3*nodes,k+(s+4)*nodes) = A(k+3*nodes,k+(s+4)*nodes) + C7; %HT to 2nd bi-polar plate
        else
            A(k+3*nodes,k+s*nodes) = A(k+3*nodes,k+s*nodes) + C7; %HT to bi-polar plate
        end

        [i,j] = find(block.Flow2Dir==k);
        if j==1 %first column averaged with inlet temperature
            if s==6 %pull last temperature from Flow3
                k2 = block.Flow3Dir(i,end);
                A(k+2*nodes,k2+(s+5)*nodes) = A(k+2*nodes,k2+(s+5)*nodes) + a*C6;
                A(k+3*nodes,k2+(s+5)*nodes) = A(k+3*nodes,k2+(s+5)*nodes) - a*(C6+C7);
                A(k+4*nodes,k2+(s+5)*nodes) = A(k+4*nodes,k2+(s+5)*nodes) + a*C7;
            else
                A(k,2*s*nodes+1) = A(k,2*s*nodes+1) + a*C7;
                A(k+2*nodes,2*s*nodes+1) = A(k+2*nodes,2*s*nodes+1) + a*C6;
                A(k+3*nodes,2*s*nodes+1) = A(k+3*nodes,2*s*nodes+1) - a*(C6+C7);
            end
        else % other columns averaged with previous one
            k2 = block.Flow2Dir(i,j-1);
            if s==4
                A(k,k2+(s+3)*nodes) = A(k,k2+(s+3)*nodes) + a*C7;
            else
                A(k+4*nodes,k2+(s+3)*nodes) = A(k+4*nodes,k2+(s+3)*nodes) + a*C7;
            end
            A(k+2*nodes,k2+(s+3)*nodes) = A(k+2*nodes,k2+(s+3)*nodes) + a*C6;
            A(k+3*nodes,k2+(s+3)*nodes) = A(k+3*nodes,k2+(s+3)*nodes) - a*(C6+C7);
        end

        if s==6 
            %QT3 : also HT from 2nd half of plate
            A(k+2*nodes,k+(s+2)*nodes) = A(k+2*nodes,k+(s+2)*nodes) - C5;
            A(k+2*nodes,k+(s+4)*nodes) = A(k+2*nodes,k+(s+4)*nodes) + C5;
            %QT5 : heat transfer into 2nd half of bi-polar plate
            A(k+4*nodes,k+4*nodes) = A(k+4*nodes,k+4*nodes) - 1;
            A(k+4*nodes,k+(s+4)*nodes) = A(k+4*nodes,k+(s+4)*nodes) - (C8+C5+C7);
            A(k+4*nodes,k+(s+5)*nodes) = A(k+4*nodes,k+(s+5)*nodes) + (1-a)*C8;
            A(k+4*nodes,k+(s+2)*nodes) = A(k+4*nodes,k+(s+2)*nodes) + C5;
            A(k+4*nodes,k+(s+3)*nodes) = A(k+4*nodes,k+(s+3)*nodes) + (1-a)*C7; 
           
            %QT6 : heat transfer into Flow3 gas
            A(k+5*nodes,k+5*nodes) = A(k+5*nodes,k+5*nodes) - 1;
            A(k+5*nodes,k+(s+5)*nodes) = A(k+5*nodes,k+(s+5)*nodes) - 2*(1-a)*C8; 
            A(k+5*nodes,k+s*nodes) = C8; 
            A(k+5*nodes,k+(s+4)*nodes) = C8; 

            [i,j] = find(block.Flow3Dir==k);
            if j==1 %first column averaged with inlet temperature
                A(k,2*s*nodes+1) = a*C8;
                A(k+4*nodes,2*s*nodes+1) = a*C8;
                A(k+5*nodes,2*s*nodes+1) = -2*a*C8;
            else % other columns averaged with previous one
                k2 = block.Flow3Dir(i,j-1);
                A(k,k2+(s+5)*nodes) = a*C8;
                A(k+4*nodes,k2+(s+5)*nodes) = a*C8;
                A(k+5*nodes,k2+(s+5)*nodes) = -2*a*C8;
            end
        end

        %Temeraure of bi-polar plate (net heat transfer into plate = 0)
        A(k+s*nodes,k) = 1;

        %Temperature of Flow1 (Air/oxidant)
        A(k+(s+1)*nodes,k+nodes) = 1;
        A(k+(s+1)*nodes,k+(s+1)*nodes) = -mdot_Cp(1);
        [i,j] = find(block.Flow1Dir==k);
        if j==1 %first column receives fresh air
            A(k+(s+1)*nodes,2*s*nodes+2) = mdot_Cp(1);%upstream (inlet)
        else
            index = block.Flow1Dir(i,j-1);
            A(k+(s+1)*nodes,index +(s+1)*nodes) = mdot_Cp(1);%upstream node
        end

        %Temperature of electrolyte
        A(k+(s+2)*nodes,k+2*nodes) = 1;

        %Temperature of Flow2
        A(k+(s+3)*nodes,k+3*nodes) = 1;
        A(k+(s+3)*nodes,k+(s+3)*nodes) = -mdot_Cp(2); 
        [i,j] = find(block.Flow2Dir==k);
        if j==1 %first column receives fresh fuel/steam
            if s==4
                A(k+(s+3)*nodes,2*s*nodes+1) = mdot_Cp(2); %upstream (fresh inlet)
            elseif s==6
                index = block.Flow3Dir(i,end);
                A(k+(s+3)*nodes,index+(s+5)*nodes) = mdot_Cp(2); %upstream (Flow3 out)
            end
        else
            index = block.Flow2Dir(i,j-1);
            A(k+(s+3)*nodes,index+(s+3)*nodes) = mdot_Cp(2);%upstream node
        end        

        if s==6 
            %Temperature of 2nd bi-polar plate (net heat transfer into plate = 0)
            A(k+(s+4)*nodes,k+4*nodes) = 1;
            %Temperature of Flow3 gas
            A(k+(s+5)*nodes,k+5*nodes) = 1;
            A(k+(s+5)*nodes,k+(s+5)*nodes) = -mdot_Cp(2);%assume same flow heat capacity as fuel/steam
            [i,j] = find(block.Flow3Dir==k);
            if j==1 %first column receives fresh fuel/steam
                A(k+(s+5)*nodes,2*s*nodes+1) = mdot_Cp(2);%fresh inlet
            else
                index = block.Flow3Dir(i,j-1);
                A(k+(s+5)*nodes,index+(s+5)*nodes) = mdot_Cp(2);
            end 
        end
    end

    %remove temperature averaging at Flow1 inlet node
    k1 = block.Flow1Dir(:,1); %first column
    for n =1:1:length(k1)
        k = k1(n);
        A(k,k+(s+1)*nodes) = A(k,k+(s+1)*nodes) + a*C2; %HT to plate from Flow1
        A(k,2*s*nodes+2) = A(k,2*s*nodes+2) - a*C2; %HT to plate from Flow1

        A(k+nodes,k+(s+1)*nodes) = A(k+nodes,k+(s+1)*nodes) - a*(C2+C3); %HT to flow 1 from plate and electrolyte
        A(k+nodes,2*s*nodes+2) = A(k+nodes,2*s*nodes+2) + a*(C2+C3);   %HT to flow 1 from plate and electrolyte

        A(k+2*nodes,k+(s+1)*nodes) = A(k+2*nodes,k+(s+1)*nodes) + a*C3;%HT to electrolyte from the Flow1
        A(k+2*nodes,2*s*nodes+2) = A(k+2*nodes,2*s*nodes+2) - a*C3; %HT to electrolyte from the Flow1
    end
    %remove temperature averaging at Flow2 inlet node
    if s==6 
        k1 = block.Flow3Dir(:,1); %first column
        for n =1:1:length(k1)
            k = k1(n);
            A(k+5*nodes,k+(s+5)*nodes) = A(k+5*nodes,k+(s+5)*nodes) - 2*a*C8; %HT to reform gas from bi-polar plates
            A(k+5*nodes,2*s*nodes+1) = A(k+5*nodes,2*s*nodes+1) + 2*a*C8; %HT to reform gas from bi-polar plates

            A(k,k+(s+5)*nodes) = A(k,k+(s+5)*nodes) + a*C8; %HT to bipolar plate from Flow3
            A(k,2*s*nodes+1) = A(k,2*s*nodes+1) - a*C8;   %HT to bipolar plate from Flow3

            A(k+4*nodes,k+(s+5)*nodes) = A(k+4*nodes,k+(s+5)*nodes) + a*C8;%HT to the 2nd plate from Flow3
            A(k+4*nodes,2*s*nodes+1) = A(k+4*nodes,2*s*nodes+1) - a*C8; %HT into the 2nd plate from Flow3
        end
    else
        k1 = block.Flow2Dir(:,1); %first column
        for n =1:1:length(k1)
            k = k1(n);
            A(k+3*nodes,k+(s+3)*nodes) = A(k+3*nodes,k+(s+3)*nodes) -a*(C6+C7); %HT to Flow2 from bipolar plate & electrolyte
            A(k+3*nodes,2*s*nodes+1) = A(k+3*nodes,2*s*nodes+1) + a*(C6+C7);   %HT to Flow2 from  bipolar plate & electrolyte

            A(k,k+(s+3)*nodes) = A(k,k+(s+3)*nodes) + a*C7; %HT from Flow2 to bi-polar plate
            A(k,2*s*nodes+1) = A(k,2*s*nodes+1) - a*C7;   %HT from Flow2 to bi-polar plate

            A(k+2*nodes,k+(s+3)*nodes) = A(k+2*nodes,k+(s+3)*nodes) + a*C6; %HT into the electrolyte from Flow2
            A(k+2*nodes,2*s*nodes+1) = A(k+2*nodes,2*s*nodes+1) - a*C6;%HT into the electrolyte from Flow2
        end
    end
end
HTconv = A(1:s*nodes,s*nodes+1:2*s*nodes);%matrix of coefficients to multiply by vector of temperature and get the heat transfer by conduction & convection between layers and nodes

%% Conduction: left and right, prev and next
A2 = zeros(states+c,states);
prev = block.HTadjacent(:,1);
next = block.HTadjacent(:,2);
left = block.HTadjacent(:,3);
right = block.HTadjacent(:,4);

%conduction coefficients
if s<=3
    %For heat exchangers and reformer
    for k = 1:1:nodes
        A2(k+nodes,k+(s+1)*nodes) = A2(k+nodes,k+(s+1)*nodes) -2*block.ConductionPN -2*block.ConductionLR;
        A2(k+nodes,prev(k)+(s+1)*nodes) = A2(k+nodes,prev(k)+(s+1)*nodes)+block.ConductionPN;
        A2(k+nodes,next(k)+(s+1)*nodes) = A2(k+nodes,next(k)+(s+1)*nodes)+block.ConductionPN;
        A2(k+nodes,left(k)+(s+1)*nodes) = A2(k+nodes,left(k)+(s+1)*nodes)+block.ConductionLR;
        A2(k+nodes,right(k)+(s+1)*nodes) = A2(k+nodes,right(k)+(s+1)*nodes)+block.ConductionLR; 
    end
else
    % For fuel cell
    H1_pn = (block.k_plate(1)*block.A_plate_heatCond(1)/(block.L_node/2))/1000; %heat transfer coefficient between previous and next node of bi-polar plate
    H1_lr  = (block.k_plate(1)*block.A_plate_heatCond(1)/(block.W_node/2))/1000; %heat transfer coefficient between left and right adjacent nodes of bi-polar plate
    H2_pn  = (block.k_Elec*block.A_Elec_Heat_Cond/(block.L_node/2))/1000; %heat transfer coefficient between previous and next node of electrolyte assembly
    H2_lr  = (block.k_Elec*block.A_Elec_Heat_Cond/(block.W_node/2))/1000; %heat transfer coefficient between left and right adjacent nodes  of electrolyte assembly

    for k = 1:1:nodes
        if prev(k) ~=k
            A2(k,k+s*nodes) = A2(k,k+s*nodes)-H1_pn;
            A2(k,prev(k)+s*nodes) = A2(k,prev(k)+s*nodes)+H1_pn;
            A2(k+2*nodes,k+(s+2)*nodes) = A2(k+2*nodes,k+(s+2)*nodes)-H2_pn;
            A2(k+2*nodes,prev(k)+(s+2)*nodes) = A2(k+2*nodes,prev(k)+(s+2)*nodes)+H2_pn;
        end
        if next(k) ~=k
            A2(k,k+s*nodes) = A2(k,k+s*nodes)-H1_pn;
            A2(k,next(k)+s*nodes) = A2(k,next(k)+s*nodes)+H1_pn;
            A2(k+2*nodes,k+(s+2)*nodes) = A2(k+2*nodes,k+(s+2)*nodes)-H2_pn;
            A2(k+2*nodes,next(k)+(s+2)*nodes) = A2(k+2*nodes,next(k)+(s+2)*nodes)+H2_pn;
        end
        if left(k) ~=k
            A2(k,k+s*nodes) = A2(k,k+s*nodes)-H1_lr;
            A2(k,left(k)+s*nodes) = A2(k,left(k)+s*nodes)+H1_lr;
            A2(k+2*nodes,k+(s+2)*nodes) = A2(k+2*nodes,k+(s+2)*nodes)-H2_lr;
            A2(k+2*nodes,left(k)+(s+2)*nodes) = A2(k+2*nodes,left(k)+(s+2)*nodes)+H2_lr;
        end
        if right(k) ~=k
            A2(k,k+s*nodes) = A2(k,k+s*nodes)-H1_lr;
            A2(k,right(k)+s*nodes) = A2(k,right(k)+s*nodes)+H1_lr;
            A2(k+2*nodes,k+(s+2)*nodes) = A2(k+2*nodes,k+(s+2)*nodes)-H2_lr;
            A2(k+2*nodes,right(k)+(s+2)*nodes) = A2(k+2*nodes,right(k)+(s+2)*nodes)+H2_lr;
        end   
    end
    
    if length(block.t_plate)>1 %calculate for 2nd plate
        H3_pn  = (block.k_plate(2)*block.A_plate_heatCond(2)/(block.L_node/2))/1000; %heat transfer coefficient between previous and next node of 2nd plate
        H3_lr  = (block.k_plate(2)*block.A_plate_heatCond(2)/(block.W_node/2))/1000; %heat transfer coefficient between left and right adjacent nodes of 2nd plate
        for k = 1:1:nodes
            if prev(k) ~=k
                A2(k+4*nodes,k+(s+4)*nodes) = A2(k+4*nodes,k+(s+4)*nodes)-H3_pn;
                A2(k+4*nodes,prev(k)+(s+4)*nodes) = A2(k+4*nodes,prev(k)+(s+4)*nodes)+H3_pn;
            end
            if next(k) ~=k
                A2(k+4*nodes,k+(s+4)*nodes) = A2(k+4*nodes,k+(s+4)*nodes)-H3_pn;
                A2(k+4*nodes,next(k)+(s+4)*nodes) = A2(k+4*nodes,next(k)+(s+4)*nodes)+H3_pn;
            end
            if left(k) ~=k
                A2(k+4*nodes,k+(s+4)*nodes) = A2(k+4*nodes,k+(s+4)*nodes)-H3_lr;
                A2(k+4*nodes,left(k)+(s+4)*nodes) = A2(k+4*nodes,left(k)+(s+4)*nodes)+H3_lr;
            end
            if right(k) ~=k
                A2(k+4*nodes,k+(s+4)*nodes) = A2(k+4*nodes,k+(s+4)*nodes)-H3_lr;
                A2(k+4*nodes,right(k)+(s+4)*nodes) = A2(k+4*nodes,right(k)+(s+4)*nodes)+H3_lr;
            end   
        end
    end
end
HTcond = A2(1:s*nodes,s*nodes+1:2*s*nodes);%matrix of coefficients to multiply by vector of temperature and get the heat transfer by conduction & convection between layers and nodes
A = A + A2;

%% Radiative Heat transfer
HTrad = zeros(s*nodes,s*nodes);


% Qscale = b(2*s*nodes+3)/max(abs(b(s*nodes+1:2*s*nodes)))/10;%scaling so more emphasis is put on balancing temperature than on balancing Q
% b(s*nodes+1:2*s*nodes) = Qscale*b(s*nodes+1:2*s*nodes);
% A(1:s*nodes,s*nodes+1:2*s*nodes+2) = Qscale*A(1:s*nodes,s*nodes+1:2*s*nodes+2);

%% Constraints
%Flow1 Inlet Temperature
A(2*s*nodes+1,2*s*nodes+1) = 1;
b(2*s*nodes+1) = T_in(1);
if inT>1 %Flow2 Inlet Temperature
    A(2*s*nodes+2,2*s*nodes+2) = 1; 
    b(2*s*nodes+2) = T_in(2);
end

if c > 0 %Average electrolyte temp  constraint 
    for j = 1:1:nodes %Average all the electrolyte temps to equal Tpenavg
        A(2*s*nodes+3,j+(s+2)*nodes) = 1/nodes;
    end 
    b(2*s*nodes+3) = block.TpenAvg;
    %Flow1 dT constraint: T3 - T2 = T2 - T1
    col = length(block.Flow1Dir(1,:));% # of columns
    rows = length(block.Flow1Dir(:,1)); % # of rows
    for i =1:1:col-1
        if i ==1
            A(2*s*nodes+3+i,2*s*nodes+1) = 1; %Flow1 inlet (T1)
        else A(2*s*nodes+3+i,block.Flow1Dir(:,i-1)+(s+1)*nodes) = 1/rows;%first column (T1)
        end
        A(2*s*nodes+3+i,block.Flow1Dir(:,i)+(s+1)*nodes) = -2/rows; %middle column (T2)
        A(2*s*nodes+3+i,block.Flow1Dir(:,i+1)+(s+1)*nodes) = 1/rows; %last column (T3)
        b(2*s*nodes+3+i) = 0;
    end
end
x= A\b;
T = x(s*nodes+1:2*s*nodes);
if ~isreal(T)
    T = real(x(s*nodes+1:2*s*nodes));
end

% %% Radiative heat transfer %%
% Ar = 0*A;
% for j = 1:s*nodes
%     Ar(1:s*nodes,s*nodes+j) = HTrad(1:s*nodes,j).*T(i).^3;
% end
% A = A + Ar;
% 
% error = true;
% a = 1; %convergence gain factor
% count = 0;
% while error % converges to correct temperatures with radiative heat transfer
%     Told = T;
%     x = A\b;
%     T = a*x(s*nodes+1:2*s*nodes) + (1-a)*Told;
%     if max(abs(T-Told))<.1
%         error = false;
%     end
%     count = count+1;
%     if count>10
%         disp('Slow convergence in radiative heat transfer')
%     end
% end
% %     QT = x(1:s*nodes);
end%Ends function SteadyTemps